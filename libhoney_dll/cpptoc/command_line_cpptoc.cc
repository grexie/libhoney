// Copyright (c) 2023 The Honeycomb Authors. All rights
// reserved. Use of this source code is governed by a BSD-style license that
// can be found in the LICENSE file.
//
// ---------------------------------------------------------------------------
//
// This file was generated by the Honeycomb translator tool. If making changes by
// hand only do so within the body of existing method and function
// implementations. See the translator.README.txt file in the tools directory
// for more information.
//
// $hash=0feacec72c147c19404395cb872cf47f02a4d092$
//

#include "libhoney_dll/cpptoc/command_line_cpptoc.h"
#include "libhoney_dll/transfer_util.h"

// GLOBAL FUNCTIONS - Body may be edited by hand.

HONEYCOMB_EXPORT honey_command_line_t* honey_command_line_create() {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  HoneycombRefPtr<HoneycombCommandLine> _retval = HoneycombCommandLine::CreateCommandLine();

  // Return type: refptr_same
  return HoneycombCommandLineCppToC::Wrap(_retval);
}

HONEYCOMB_EXPORT honey_command_line_t* honey_command_line_get_global() {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  HoneycombRefPtr<HoneycombCommandLine> _retval = HoneycombCommandLine::GetGlobalCommandLine();

  // Return type: refptr_same
  return HoneycombCommandLineCppToC::Wrap(_retval);
}

namespace {

// MEMBER FUNCTIONS - Body may be edited by hand.

int HONEYCOMB_CALLBACK command_line_is_valid(struct _honey_command_line_t* self) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return 0;
  }

  // Execute
  bool _retval = HoneycombCommandLineCppToC::Get(self)->IsValid();

  // Return type: bool
  return _retval;
}

int HONEYCOMB_CALLBACK command_line_is_read_only(struct _honey_command_line_t* self) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return 0;
  }

  // Execute
  bool _retval = HoneycombCommandLineCppToC::Get(self)->IsReadOnly();

  // Return type: bool
  return _retval;
}

struct _honey_command_line_t* HONEYCOMB_CALLBACK
command_line_copy(struct _honey_command_line_t* self) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return NULL;
  }

  // Execute
  HoneycombRefPtr<HoneycombCommandLine> _retval = HoneycombCommandLineCppToC::Get(self)->Copy();

  // Return type: refptr_same
  return HoneycombCommandLineCppToC::Wrap(_retval);
}

void HONEYCOMB_CALLBACK command_line_init_from_argv(struct _honey_command_line_t* self,
                                              int argc,
                                              const char* const* argv) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return;
  }
  // Verify param: argv; type: simple_byaddr
  DCHECK(argv);
  if (!argv) {
    return;
  }

  // Execute
  HoneycombCommandLineCppToC::Get(self)->InitFromArgv(argc, argv);
}

void HONEYCOMB_CALLBACK
command_line_init_from_string(struct _honey_command_line_t* self,
                              const honey_string_t* command_line) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return;
  }
  // Verify param: command_line; type: string_byref_const
  DCHECK(command_line);
  if (!command_line) {
    return;
  }

  // Execute
  HoneycombCommandLineCppToC::Get(self)->InitFromString(HoneycombString(command_line));
}

void HONEYCOMB_CALLBACK command_line_reset(struct _honey_command_line_t* self) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return;
  }

  // Execute
  HoneycombCommandLineCppToC::Get(self)->Reset();
}

void HONEYCOMB_CALLBACK command_line_get_argv(struct _honey_command_line_t* self,
                                        honey_string_list_t argv) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return;
  }
  // Verify param: argv; type: string_vec_byref
  DCHECK(argv);
  if (!argv) {
    return;
  }

  // Translate param: argv; type: string_vec_byref
  std::vector<HoneycombString> argvList;
  transfer_string_list_contents(argv, argvList);

  // Execute
  HoneycombCommandLineCppToC::Get(self)->GetArgv(argvList);

  // Restore param: argv; type: string_vec_byref
  honey_string_list_clear(argv);
  transfer_string_list_contents(argvList, argv);
}

honey_string_userfree_t HONEYCOMB_CALLBACK
command_line_get_command_line_string(struct _honey_command_line_t* self) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return NULL;
  }

  // Execute
  HoneycombString _retval = HoneycombCommandLineCppToC::Get(self)->GetCommandLineString();

  // Return type: string
  return _retval.DetachToUserFree();
}

honey_string_userfree_t HONEYCOMB_CALLBACK
command_line_get_program(struct _honey_command_line_t* self) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return NULL;
  }

  // Execute
  HoneycombString _retval = HoneycombCommandLineCppToC::Get(self)->GetProgram();

  // Return type: string
  return _retval.DetachToUserFree();
}

void HONEYCOMB_CALLBACK command_line_set_program(struct _honey_command_line_t* self,
                                           const honey_string_t* program) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return;
  }
  // Verify param: program; type: string_byref_const
  DCHECK(program);
  if (!program) {
    return;
  }

  // Execute
  HoneycombCommandLineCppToC::Get(self)->SetProgram(HoneycombString(program));
}

int HONEYCOMB_CALLBACK command_line_has_switches(struct _honey_command_line_t* self) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return 0;
  }

  // Execute
  bool _retval = HoneycombCommandLineCppToC::Get(self)->HasSwitches();

  // Return type: bool
  return _retval;
}

int HONEYCOMB_CALLBACK command_line_has_switch(struct _honey_command_line_t* self,
                                         const honey_string_t* name) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return 0;
  }
  // Verify param: name; type: string_byref_const
  DCHECK(name);
  if (!name) {
    return 0;
  }

  // Execute
  bool _retval = HoneycombCommandLineCppToC::Get(self)->HasSwitch(HoneycombString(name));

  // Return type: bool
  return _retval;
}

honey_string_userfree_t HONEYCOMB_CALLBACK
command_line_get_switch_value(struct _honey_command_line_t* self,
                              const honey_string_t* name) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return NULL;
  }
  // Verify param: name; type: string_byref_const
  DCHECK(name);
  if (!name) {
    return NULL;
  }

  // Execute
  HoneycombString _retval =
      HoneycombCommandLineCppToC::Get(self)->GetSwitchValue(HoneycombString(name));

  // Return type: string
  return _retval.DetachToUserFree();
}

void HONEYCOMB_CALLBACK command_line_get_switches(struct _honey_command_line_t* self,
                                            honey_string_map_t switches) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return;
  }
  // Verify param: switches; type: string_map_single_byref
  DCHECK(switches);
  if (!switches) {
    return;
  }

  // Translate param: switches; type: string_map_single_byref
  std::map<HoneycombString, HoneycombString> switchesMap;
  transfer_string_map_contents(switches, switchesMap);

  // Execute
  HoneycombCommandLineCppToC::Get(self)->GetSwitches(switchesMap);

  // Restore param: switches; type: string_map_single_byref
  honey_string_map_clear(switches);
  transfer_string_map_contents(switchesMap, switches);
}

void HONEYCOMB_CALLBACK command_line_append_switch(struct _honey_command_line_t* self,
                                             const honey_string_t* name) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return;
  }
  // Verify param: name; type: string_byref_const
  DCHECK(name);
  if (!name) {
    return;
  }

  // Execute
  HoneycombCommandLineCppToC::Get(self)->AppendSwitch(HoneycombString(name));
}

void HONEYCOMB_CALLBACK
command_line_append_switch_with_value(struct _honey_command_line_t* self,
                                      const honey_string_t* name,
                                      const honey_string_t* value) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return;
  }
  // Verify param: name; type: string_byref_const
  DCHECK(name);
  if (!name) {
    return;
  }
  // Verify param: value; type: string_byref_const
  DCHECK(value);
  if (!value) {
    return;
  }

  // Execute
  HoneycombCommandLineCppToC::Get(self)->AppendSwitchWithValue(HoneycombString(name),
                                                         HoneycombString(value));
}

int HONEYCOMB_CALLBACK command_line_has_arguments(struct _honey_command_line_t* self) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return 0;
  }

  // Execute
  bool _retval = HoneycombCommandLineCppToC::Get(self)->HasArguments();

  // Return type: bool
  return _retval;
}

void HONEYCOMB_CALLBACK command_line_get_arguments(struct _honey_command_line_t* self,
                                             honey_string_list_t arguments) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return;
  }
  // Verify param: arguments; type: string_vec_byref
  DCHECK(arguments);
  if (!arguments) {
    return;
  }

  // Translate param: arguments; type: string_vec_byref
  std::vector<HoneycombString> argumentsList;
  transfer_string_list_contents(arguments, argumentsList);

  // Execute
  HoneycombCommandLineCppToC::Get(self)->GetArguments(argumentsList);

  // Restore param: arguments; type: string_vec_byref
  honey_string_list_clear(arguments);
  transfer_string_list_contents(argumentsList, arguments);
}

void HONEYCOMB_CALLBACK command_line_append_argument(struct _honey_command_line_t* self,
                                               const honey_string_t* argument) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return;
  }
  // Verify param: argument; type: string_byref_const
  DCHECK(argument);
  if (!argument) {
    return;
  }

  // Execute
  HoneycombCommandLineCppToC::Get(self)->AppendArgument(HoneycombString(argument));
}

void HONEYCOMB_CALLBACK command_line_prepend_wrapper(struct _honey_command_line_t* self,
                                               const honey_string_t* wrapper) {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  DCHECK(self);
  if (!self) {
    return;
  }
  // Verify param: wrapper; type: string_byref_const
  DCHECK(wrapper);
  if (!wrapper) {
    return;
  }

  // Execute
  HoneycombCommandLineCppToC::Get(self)->PrependWrapper(HoneycombString(wrapper));
}

}  // namespace

// CONSTRUCTOR - Do not edit by hand.

HoneycombCommandLineCppToC::HoneycombCommandLineCppToC() {
  GetStruct()->is_valid = command_line_is_valid;
  GetStruct()->is_read_only = command_line_is_read_only;
  GetStruct()->copy = command_line_copy;
  GetStruct()->init_from_argv = command_line_init_from_argv;
  GetStruct()->init_from_string = command_line_init_from_string;
  GetStruct()->reset = command_line_reset;
  GetStruct()->get_argv = command_line_get_argv;
  GetStruct()->get_command_line_string = command_line_get_command_line_string;
  GetStruct()->get_program = command_line_get_program;
  GetStruct()->set_program = command_line_set_program;
  GetStruct()->has_switches = command_line_has_switches;
  GetStruct()->has_switch = command_line_has_switch;
  GetStruct()->get_switch_value = command_line_get_switch_value;
  GetStruct()->get_switches = command_line_get_switches;
  GetStruct()->append_switch = command_line_append_switch;
  GetStruct()->append_switch_with_value = command_line_append_switch_with_value;
  GetStruct()->has_arguments = command_line_has_arguments;
  GetStruct()->get_arguments = command_line_get_arguments;
  GetStruct()->append_argument = command_line_append_argument;
  GetStruct()->prepend_wrapper = command_line_prepend_wrapper;
}

// DESTRUCTOR - Do not edit by hand.

HoneycombCommandLineCppToC::~HoneycombCommandLineCppToC() {}

template <>
HoneycombRefPtr<HoneycombCommandLine>
HoneycombCppToCRefCounted<HoneycombCommandLineCppToC, HoneycombCommandLine, honey_command_line_t>::
    UnwrapDerived(HoneycombWrapperType type, honey_command_line_t* s) {
  DCHECK(false) << "Unexpected class type: " << type;
  return nullptr;
}

template <>
HoneycombWrapperType HoneycombCppToCRefCounted<HoneycombCommandLineCppToC,
                                   HoneycombCommandLine,
                                   honey_command_line_t>::kWrapperType =
    WT_COMMAND_LINE;
