// Copyright (c) 2023 The Honeycomb Authors. All rights
// reserved. Use of this source code is governed by a BSD-style license that
// can be found in the LICENSE file.
//
// ---------------------------------------------------------------------------
//
// This file was generated by the Honeycomb translator tool. If making changes by
// hand only do so within the body of existing method and function
// implementations. See the translator.README.txt file in the tools directory
// for more information.
//
// $hash=f94b3d675dfb95c556fb4b3f8c618507aeca89ad$
//

#include "libhoneycomb_dll/ctocpp/server_handler_ctocpp.h"
#include "libhoneycomb_dll/cpptoc/callback_cpptoc.h"
#include "libhoneycomb_dll/cpptoc/request_cpptoc.h"
#include "libhoneycomb_dll/cpptoc/server_cpptoc.h"
#include "libhoneycomb_dll/shutdown_checker.h"

// VIRTUAL METHODS - Body may be edited by hand.

NO_SANITIZE("cfi-icall")
void HoneycombServerHandlerCToCpp::OnServerCreated(HoneycombRefPtr<HoneycombServer> server) {
  shutdown_checker::AssertNotShutdown();

  honey_server_handler_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, on_server_created)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: server; type: refptr_diff
  DCHECK(server.get());
  if (!server.get()) {
    return;
  }

  // Execute
  _struct->on_server_created(_struct, HoneycombServerCppToC::Wrap(server));
}

NO_SANITIZE("cfi-icall")
void HoneycombServerHandlerCToCpp::OnServerDestroyed(HoneycombRefPtr<HoneycombServer> server) {
  shutdown_checker::AssertNotShutdown();

  honey_server_handler_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, on_server_destroyed)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: server; type: refptr_diff
  DCHECK(server.get());
  if (!server.get()) {
    return;
  }

  // Execute
  _struct->on_server_destroyed(_struct, HoneycombServerCppToC::Wrap(server));
}

NO_SANITIZE("cfi-icall")
void HoneycombServerHandlerCToCpp::OnClientConnected(HoneycombRefPtr<HoneycombServer> server,
                                               int connection_id) {
  shutdown_checker::AssertNotShutdown();

  honey_server_handler_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, on_client_connected)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: server; type: refptr_diff
  DCHECK(server.get());
  if (!server.get()) {
    return;
  }

  // Execute
  _struct->on_client_connected(_struct, HoneycombServerCppToC::Wrap(server),
                               connection_id);
}

NO_SANITIZE("cfi-icall")
void HoneycombServerHandlerCToCpp::OnClientDisconnected(HoneycombRefPtr<HoneycombServer> server,
                                                  int connection_id) {
  shutdown_checker::AssertNotShutdown();

  honey_server_handler_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, on_client_disconnected)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: server; type: refptr_diff
  DCHECK(server.get());
  if (!server.get()) {
    return;
  }

  // Execute
  _struct->on_client_disconnected(_struct, HoneycombServerCppToC::Wrap(server),
                                  connection_id);
}

NO_SANITIZE("cfi-icall")
void HoneycombServerHandlerCToCpp::OnHttpRequest(HoneycombRefPtr<HoneycombServer> server,
                                           int connection_id,
                                           const HoneycombString& client_address,
                                           HoneycombRefPtr<HoneycombRequest> request) {
  shutdown_checker::AssertNotShutdown();

  honey_server_handler_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, on_http_request)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: server; type: refptr_diff
  DCHECK(server.get());
  if (!server.get()) {
    return;
  }
  // Verify param: client_address; type: string_byref_const
  DCHECK(!client_address.empty());
  if (client_address.empty()) {
    return;
  }
  // Verify param: request; type: refptr_diff
  DCHECK(request.get());
  if (!request.get()) {
    return;
  }

  // Execute
  _struct->on_http_request(_struct, HoneycombServerCppToC::Wrap(server),
                           connection_id, client_address.GetStruct(),
                           HoneycombRequestCppToC::Wrap(request));
}

NO_SANITIZE("cfi-icall")
void HoneycombServerHandlerCToCpp::OnWebSocketRequest(
    HoneycombRefPtr<HoneycombServer> server,
    int connection_id,
    const HoneycombString& client_address,
    HoneycombRefPtr<HoneycombRequest> request,
    HoneycombRefPtr<HoneycombCallback> callback) {
  shutdown_checker::AssertNotShutdown();

  honey_server_handler_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, on_web_socket_request)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: server; type: refptr_diff
  DCHECK(server.get());
  if (!server.get()) {
    return;
  }
  // Verify param: client_address; type: string_byref_const
  DCHECK(!client_address.empty());
  if (client_address.empty()) {
    return;
  }
  // Verify param: request; type: refptr_diff
  DCHECK(request.get());
  if (!request.get()) {
    return;
  }
  // Verify param: callback; type: refptr_diff
  DCHECK(callback.get());
  if (!callback.get()) {
    return;
  }

  // Execute
  _struct->on_web_socket_request(_struct, HoneycombServerCppToC::Wrap(server),
                                 connection_id, client_address.GetStruct(),
                                 HoneycombRequestCppToC::Wrap(request),
                                 HoneycombCallbackCppToC::Wrap(callback));
}

NO_SANITIZE("cfi-icall")
void HoneycombServerHandlerCToCpp::OnWebSocketConnected(HoneycombRefPtr<HoneycombServer> server,
                                                  int connection_id) {
  shutdown_checker::AssertNotShutdown();

  honey_server_handler_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, on_web_socket_connected)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: server; type: refptr_diff
  DCHECK(server.get());
  if (!server.get()) {
    return;
  }

  // Execute
  _struct->on_web_socket_connected(_struct, HoneycombServerCppToC::Wrap(server),
                                   connection_id);
}

NO_SANITIZE("cfi-icall")
void HoneycombServerHandlerCToCpp::OnWebSocketMessage(HoneycombRefPtr<HoneycombServer> server,
                                                int connection_id,
                                                const void* data,
                                                size_t data_size) {
  shutdown_checker::AssertNotShutdown();

  honey_server_handler_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, on_web_socket_message)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: server; type: refptr_diff
  DCHECK(server.get());
  if (!server.get()) {
    return;
  }
  // Verify param: data; type: simple_byaddr
  DCHECK(data);
  if (!data) {
    return;
  }

  // Execute
  _struct->on_web_socket_message(_struct, HoneycombServerCppToC::Wrap(server),
                                 connection_id, data, data_size);
}

// CONSTRUCTOR - Do not edit by hand.

HoneycombServerHandlerCToCpp::HoneycombServerHandlerCToCpp() {}

// DESTRUCTOR - Do not edit by hand.

HoneycombServerHandlerCToCpp::~HoneycombServerHandlerCToCpp() {
  shutdown_checker::AssertNotShutdown();
}

template <>
honey_server_handler_t*
HoneycombCToCppRefCounted<HoneycombServerHandlerCToCpp,
                    HoneycombServerHandler,
                    honey_server_handler_t>::UnwrapDerived(HoneycombWrapperType type,
                                                         HoneycombServerHandler* c) {
  DCHECK(false) << "Unexpected class type: " << type;
  return nullptr;
}

template <>
HoneycombWrapperType HoneycombCToCppRefCounted<HoneycombServerHandlerCToCpp,
                                   HoneycombServerHandler,
                                   honey_server_handler_t>::kWrapperType =
    WT_SERVER_HANDLER;
