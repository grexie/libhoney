// Copyright (c) 2023 The Honeycomb Authors. All rights
// reserved. Use of this source code is governed by a BSD-style license that
// can be found in the LICENSE file.
//
// ---------------------------------------------------------------------------
//
// This file was generated by the Honeycomb translator tool. If making changes by
// hand only do so within the body of existing method and function
// implementations. See the translator.README.txt file in the tools directory
// for more information.
//
// $hash=aeb30347dcf0a11ee20524f07fe7eb980c2163f2$
//

#include "libhoneycomb_dll/ctocpp/command_line_ctocpp.h"
#include "include/honey_api_hash.h"
#include "libhoneycomb_dll/transfer_util.h"

// STATIC METHODS - Body may be edited by hand.

NO_SANITIZE("cfi-icall")
HoneycombRefPtr<HoneycombCommandLine> HoneycombCommandLine::CreateCommandLine() {
  const char* api_hash = honey_api_hash(0);
  if (strcmp(api_hash, HONEYCOMB_API_HASH_PLATFORM)) {
    // The libhoneycomb API hash does not match the current header API hash.
    DCHECK(false);
    return nullptr;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  honey_command_line_t* _retval = honey_command_line_create();

  // Return type: refptr_same
  return HoneycombCommandLineCToCpp::Wrap(_retval);
}

NO_SANITIZE("cfi-icall")
HoneycombRefPtr<HoneycombCommandLine> HoneycombCommandLine::GetGlobalCommandLine() {
  const char* api_hash = honey_api_hash(0);
  if (strcmp(api_hash, HONEYCOMB_API_HASH_PLATFORM)) {
    // The libhoneycomb API hash does not match the current header API hash.
    DCHECK(false);
    return nullptr;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  honey_command_line_t* _retval = honey_command_line_get_global();

  // Return type: refptr_same
  return HoneycombCommandLineCToCpp::Wrap(_retval);
}

// VIRTUAL METHODS - Body may be edited by hand.

NO_SANITIZE("cfi-icall") bool HoneycombCommandLineCToCpp::IsValid() {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, is_valid)) {
    return false;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  int _retval = _struct->is_valid(_struct);

  // Return type: bool
  return _retval ? true : false;
}

NO_SANITIZE("cfi-icall") bool HoneycombCommandLineCToCpp::IsReadOnly() {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, is_read_only)) {
    return false;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  int _retval = _struct->is_read_only(_struct);

  // Return type: bool
  return _retval ? true : false;
}

NO_SANITIZE("cfi-icall")
HoneycombRefPtr<HoneycombCommandLine> HoneycombCommandLineCToCpp::Copy() {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, copy)) {
    return nullptr;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  honey_command_line_t* _retval = _struct->copy(_struct);

  // Return type: refptr_same
  return HoneycombCommandLineCToCpp::Wrap(_retval);
}

NO_SANITIZE("cfi-icall")
void HoneycombCommandLineCToCpp::InitFromArgv(int argc, const char* const* argv) {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, init_from_argv)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: argv; type: simple_byaddr
  DCHECK(argv);
  if (!argv) {
    return;
  }

  // Execute
  _struct->init_from_argv(_struct, argc, argv);
}

NO_SANITIZE("cfi-icall")
void HoneycombCommandLineCToCpp::InitFromString(const HoneycombString& command_line) {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, init_from_string)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: command_line; type: string_byref_const
  DCHECK(!command_line.empty());
  if (command_line.empty()) {
    return;
  }

  // Execute
  _struct->init_from_string(_struct, command_line.GetStruct());
}

NO_SANITIZE("cfi-icall") void HoneycombCommandLineCToCpp::Reset() {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, reset)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  _struct->reset(_struct);
}

NO_SANITIZE("cfi-icall")
void HoneycombCommandLineCToCpp::GetArgv(std::vector<HoneycombString>& argv) {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, get_argv)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: argv; type: string_vec_byref
  honey_string_list_t argvList = honey_string_list_alloc();
  DCHECK(argvList);
  if (argvList) {
    transfer_string_list_contents(argv, argvList);
  }

  // Execute
  _struct->get_argv(_struct, argvList);

  // Restore param:argv; type: string_vec_byref
  if (argvList) {
    argv.clear();
    transfer_string_list_contents(argvList, argv);
    honey_string_list_free(argvList);
  }
}

NO_SANITIZE("cfi-icall")
HoneycombString HoneycombCommandLineCToCpp::GetCommandLineString() {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, get_command_line_string)) {
    return HoneycombString();
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  honey_string_userfree_t _retval = _struct->get_command_line_string(_struct);

  // Return type: string
  HoneycombString _retvalStr;
  _retvalStr.AttachToUserFree(_retval);
  return _retvalStr;
}

NO_SANITIZE("cfi-icall") HoneycombString HoneycombCommandLineCToCpp::GetProgram() {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, get_program)) {
    return HoneycombString();
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  honey_string_userfree_t _retval = _struct->get_program(_struct);

  // Return type: string
  HoneycombString _retvalStr;
  _retvalStr.AttachToUserFree(_retval);
  return _retvalStr;
}

NO_SANITIZE("cfi-icall")
void HoneycombCommandLineCToCpp::SetProgram(const HoneycombString& program) {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, set_program)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: program; type: string_byref_const
  DCHECK(!program.empty());
  if (program.empty()) {
    return;
  }

  // Execute
  _struct->set_program(_struct, program.GetStruct());
}

NO_SANITIZE("cfi-icall") bool HoneycombCommandLineCToCpp::HasSwitches() {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, has_switches)) {
    return false;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  int _retval = _struct->has_switches(_struct);

  // Return type: bool
  return _retval ? true : false;
}

NO_SANITIZE("cfi-icall")
bool HoneycombCommandLineCToCpp::HasSwitch(const HoneycombString& name) {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, has_switch)) {
    return false;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: name; type: string_byref_const
  DCHECK(!name.empty());
  if (name.empty()) {
    return false;
  }

  // Execute
  int _retval = _struct->has_switch(_struct, name.GetStruct());

  // Return type: bool
  return _retval ? true : false;
}

NO_SANITIZE("cfi-icall")
HoneycombString HoneycombCommandLineCToCpp::GetSwitchValue(const HoneycombString& name) {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, get_switch_value)) {
    return HoneycombString();
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: name; type: string_byref_const
  DCHECK(!name.empty());
  if (name.empty()) {
    return HoneycombString();
  }

  // Execute
  honey_string_userfree_t _retval =
      _struct->get_switch_value(_struct, name.GetStruct());

  // Return type: string
  HoneycombString _retvalStr;
  _retvalStr.AttachToUserFree(_retval);
  return _retvalStr;
}

NO_SANITIZE("cfi-icall")
void HoneycombCommandLineCToCpp::GetSwitches(SwitchMap& switches) {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, get_switches)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: switches; type: string_map_single_byref
  honey_string_map_t switchesMap = honey_string_map_alloc();
  DCHECK(switchesMap);
  if (switchesMap) {
    transfer_string_map_contents(switches, switchesMap);
  }

  // Execute
  _struct->get_switches(_struct, switchesMap);

  // Restore param:switches; type: string_map_single_byref
  if (switchesMap) {
    switches.clear();
    transfer_string_map_contents(switchesMap, switches);
    honey_string_map_free(switchesMap);
  }
}

NO_SANITIZE("cfi-icall")
void HoneycombCommandLineCToCpp::AppendSwitch(const HoneycombString& name) {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, append_switch)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: name; type: string_byref_const
  DCHECK(!name.empty());
  if (name.empty()) {
    return;
  }

  // Execute
  _struct->append_switch(_struct, name.GetStruct());
}

NO_SANITIZE("cfi-icall")
void HoneycombCommandLineCToCpp::AppendSwitchWithValue(const HoneycombString& name,
                                                 const HoneycombString& value) {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, append_switch_with_value)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: name; type: string_byref_const
  DCHECK(!name.empty());
  if (name.empty()) {
    return;
  }
  // Verify param: value; type: string_byref_const
  DCHECK(!value.empty());
  if (value.empty()) {
    return;
  }

  // Execute
  _struct->append_switch_with_value(_struct, name.GetStruct(),
                                    value.GetStruct());
}

NO_SANITIZE("cfi-icall") bool HoneycombCommandLineCToCpp::HasArguments() {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, has_arguments)) {
    return false;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  int _retval = _struct->has_arguments(_struct);

  // Return type: bool
  return _retval ? true : false;
}

NO_SANITIZE("cfi-icall")
void HoneycombCommandLineCToCpp::GetArguments(ArgumentList& arguments) {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, get_arguments)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: arguments; type: string_vec_byref
  honey_string_list_t argumentsList = honey_string_list_alloc();
  DCHECK(argumentsList);
  if (argumentsList) {
    transfer_string_list_contents(arguments, argumentsList);
  }

  // Execute
  _struct->get_arguments(_struct, argumentsList);

  // Restore param:arguments; type: string_vec_byref
  if (argumentsList) {
    arguments.clear();
    transfer_string_list_contents(argumentsList, arguments);
    honey_string_list_free(argumentsList);
  }
}

NO_SANITIZE("cfi-icall")
void HoneycombCommandLineCToCpp::AppendArgument(const HoneycombString& argument) {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, append_argument)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: argument; type: string_byref_const
  DCHECK(!argument.empty());
  if (argument.empty()) {
    return;
  }

  // Execute
  _struct->append_argument(_struct, argument.GetStruct());
}

NO_SANITIZE("cfi-icall")
void HoneycombCommandLineCToCpp::PrependWrapper(const HoneycombString& wrapper) {
  honey_command_line_t* _struct = GetStruct();
  if (HONEYCOMB_MEMBER_MISSING(_struct, prepend_wrapper)) {
    return;
  }

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: wrapper; type: string_byref_const
  DCHECK(!wrapper.empty());
  if (wrapper.empty()) {
    return;
  }

  // Execute
  _struct->prepend_wrapper(_struct, wrapper.GetStruct());
}

// CONSTRUCTOR - Do not edit by hand.

HoneycombCommandLineCToCpp::HoneycombCommandLineCToCpp() {}

// DESTRUCTOR - Do not edit by hand.

HoneycombCommandLineCToCpp::~HoneycombCommandLineCToCpp() {}

template <>
honey_command_line_t*
HoneycombCToCppRefCounted<HoneycombCommandLineCToCpp, HoneycombCommandLine, honey_command_line_t>::
    UnwrapDerived(HoneycombWrapperType type, HoneycombCommandLine* c) {
  DCHECK(false) << "Unexpected class type: " << type;
  return nullptr;
}

template <>
HoneycombWrapperType HoneycombCToCppRefCounted<HoneycombCommandLineCToCpp,
                                   HoneycombCommandLine,
                                   honey_command_line_t>::kWrapperType =
    WT_COMMAND_LINE;
